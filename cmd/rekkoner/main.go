package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/dbmedialab/rekkoner"
	"github.com/dbmedialab/rekkoner/velcro/k8s"
)

func main() {
	// Find k8s objects in files.
	intent := rekkoner.Intent{}.Init()
	rootPath := os.Args[1]
	fileCount := 0 // just for informational purposes
	walkFunc := func(path string, info os.FileInfo, err error) error {
		// Only interested in plain files.
		if !info.Mode().IsRegular() {
			return nil
		}
		// Do some filtering by name.
		// TODO This should get either more rigorous or more flag-controlled or... something.
		// ECOSYSTEM: issue with secrets files in truthy may or may not be parsible depending on git-filter state fun.
		switch filepath.Ext(path) {
		case ".yaml", ".yml":
			// pass!
		default:
			log.Printf("skipping %q, not yaml extension", path)
			return nil
		}
		// Open file and parse.
		// The k8s parser will error for things like "Object 'Kind' is missing",
		//  so we're fairlyyyy sure we've got sane k8s objects if no error.
		f, err := os.OpenFile(path, os.O_RDONLY, 0)
		if err != nil {
			log.Printf("error: %q: %s\n", path, err)
		}
		objs, err := k8s.DecodeObjects(f)
		if err != nil {
			log.Printf("error: %q: %s\n", path, err)
		}
		// Merge objs, labelling them with the file they originate from.
		relPath := strings.TrimSuffix(strings.TrimPrefix(path, rootPath), filepath.Ext(path))
		switch len(objs) {
		case 0:
			// an error?
		case 1:
			fileCount++
			intentPath := rekkoner.IntentPath(relPath)
			intent.Objs[intentPath] = objs[0]
		default:
			for i, obj := range objs {
				intentPath := rekkoner.IntentPath(fmt.Sprintf("%s!%d", relPath, i))
				intent.Objs[intentPath] = obj
			}
		}
		return nil
	}
	if err := filepath.Walk(rootPath, walkFunc); err != nil {
		log.Fatalf("error: %s\n", err)
	}
	intent.Sync()

	// Doing some grouping.
	objsGroupByKind := map[string][]unstructured.Unstructured{}
	for _, obj := range intent.Objs {
		kind := obj.Object["kind"].(string)
		objsGroupByKind[kind] = append(objsGroupByKind[kind], obj)
	}

	// Range over our discoveries and print some summary.
	fmt.Printf("Found %d objects in %d files:\n", len(intent.Objs), fileCount)
	for _, persp := range perspectiveCfg {
		fmt.Printf("  % 22s : %d\n", persp.Kind, len(objsGroupByKind[persp.Kind]))
		// TODO handle unknowns
	}
	fmt.Printf("In short, here are all the objs:\n")
	for _, intentPath := range intent.Keys {
		obj := intent.Objs[intentPath]
		fmt.Printf("    %-54s >> %s\n", intentPath, perspectiveMap[obj.Object["kind"].(string)].Shortname(obj))
	}
	fmt.Printf("--------------------------\n")

	// Okay funtime: clouds:
	// Get lists of all objects of the kinds we have perspective on.
	// (We'll figure out joins between this and the intent later.)
	cli, err := k8s.LoadClientConfig(os.Getenv("KUBECONFIG"))
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Fetching cluster info...\n")
	cloudByKindGather := map[string]chan []k8s.Unstructured{}
	for _, persp := range perspectiveCfg {
		cloudByKindGather[persp.Kind] = make(chan []k8s.Unstructured)
	}
	for _, persp := range perspectiveCfg {
		go func(persp Perspective) {
			defer close(cloudByKindGather[persp.Kind])
			list, err := cli.Protorequest(persp.Kind, "").List(k8s.ListOptions{})
			if err != nil {
				log.Printf("error fetching %s: %s\n", persp.Kind, err)
				return
			}
			cloudByKindGather[persp.Kind] <- k8s.UnwrapList(list)
		}(persp)
	}
	cloudByKind := map[string][]k8s.Unstructured{}
	for k, ch := range cloudByKindGather {
		cloudByKind[k] = <-ch
	}

	fmt.Printf("Here are all the objs of those kinds in the cluster:\n")
	for _, persp := range perspectiveCfg {
		for _, obj := range cloudByKind[persp.Kind] {
			fmt.Printf("    %-54s >> %s\n", "", persp.Shortname(obj))
		}
	}

	// Join cloud and intent...

	// First: ignore anything in the cloud that has 'metadata.ownerReferences'.
	for _, persp := range perspectiveCfg {
		ni := 0
		for _, v := range cloudByKind[persp.Kind] {
			ownerRef := v.Object["metadata"].(map[string]interface{})["ownerReferences"]
			if ownerRef != nil {
				log.Printf("obj %s has an ownerReference (%q); we can thus ignore it\n", persp.Shortname(v), ownerRef)
				continue
			}
			cloudByKind[persp.Kind][ni] = v
			ni++
		}
		cloudByKind[persp.Kind] = cloudByKind[persp.Kind][:ni]
	}

	for _, intentPath := range intent.Keys {
		obj := intent.Objs[intentPath]
		// TODO attempt to compare by ns:kind:name tuple.
		_ = obj
	}

}

// Commentary on some things that become 1:n:
//
// - Pods -- if set up with generateName.
// - PersistentVolume -- can be generated by StatefulSet
// - PersistentVolumeClaim -- can be generated by StatefulSet
// - ... probably many more; the 'spec' pattern is used
//   by several kubernetes objects nowaday.

var perspectiveCfg = []Perspective{
	{"Namespace", "*.{{.kind}}.{{.metadata.name}}"}, // not namespaced (obviously)
	{"Service", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"Deployment", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"ConfigMap", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"Ingress", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"StatefulSet", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"PersistentVolumeClaim", "{{.metadata.namespace}}.{{.kind}}.{{.metadata.name}}"},
	{"PersistentVolume", "*.{{.kind}}.{{.metadata.name}}"}, // not namespaced
}

var perspectiveMap = map[string]Perspective{}

func init() {
	for _, persp := range perspectiveCfg {
		perspectiveMap[persp.Kind] = persp
	}
}

// Perspective configures how we see certain Kinds of k8s object.
// We use it to govern how we print shorthand references to it,
// which fields we diff aggressively vs ignore, etc.
type Perspective struct {
	Kind              string // kind name.  CamelCase, as in k8s.
	ShortnameTemplate string
}

func (p Perspective) Shortname(obj unstructured.Unstructured) string {
	return tmpl(p.ShortnameTemplate, obj.Object)
}

func tmpl(tmpl string, obj interface{}) string {
	t := template.Must(template.New("").Parse(tmpl))
	var buf bytes.Buffer
	t.Execute(&buf, obj)
	return buf.String()
}
